Selecione o arquivo de produtos:<BR>

<!DOCTYPE html>
<html>
<body onload="OnSelectFile()">

<input type="file" id="myFile" multiple size="50" onchange="OnSelectFile()">

<p id="demo"></p>
  
<script>

const iMaxPerCsv = 500;
// Select file:
function OnSelectFile(){
  var x = document.getElementById("myFile");
  var txt = "";
  if ('files' in x) {
    if (x.files.length == 0) {
      txt = "Select one or more files.";
    } else {
      for (var i = 0; i < x.files.length; i++) {
      
     	 var file = x.files[i];
        var reader = new FileReader();
        reader.onload = function() {
        	// aqui ta o resultado conteudo do text
			var vCsvFiles = ExportProductData(reader.result);
			console.log("files: " + vCsvFiles.length);
			for (var iFile in vCsvFiles) {
				download("produtos "+ (parseInt(iFile)+1) +" de "+vCsvFiles.length+".csv", vCsvFiles[iFile]);
			}
            
        }
        reader.readAsText(file);
        
      }
    }
  } 
  else {
    if (x.value == "") {
      txt += "Select one or more files.";
    } else {
      txt += "The files property is not supported by your browser!";
      txt  += "<br>The path of the selected file: " + x.value; // If the browser does not support the files property, it will return the path of the selected file instead. 
    }
  }
  document.getElementById("demo").innerHTML = txt;
}


// Download file:
function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}


// Process stuff:

//var m_sImportTestData = require('./tests')

// all values from given index are shift to left
// Called when found a wrong value, at MEDIDA, when it is not "un"
function ShiftArray(vArray, iIndex) {
  var iMax = vArray.length - 1;
  for (var i = iIndex; i < iMax; ++i) {
      vArray[i] = vArray[i + 1];
  }
}

function _testShitArray() {
  var vRow = ["desc1", "desc2", "0", "un", "213,99", "10/20/2002"]
  ShiftArray(vRow, 2);
  
  if (vRow[2] != "un") {
    console.log(arguments.callee.name + ": Failed test")
    console.log(vRow)
  }
  else {
    console.log(arguments.callee.name + ": Success")
  }
 
}
_testShitArray();



/*
* Merges certain values of a given array into a index.
* Used to merge all "Desc" fields into a single "Desc" index.
* iIndex is the starting index (the index that is not removed)
* iLengt is the amount of indices to remove, should be 1 or higher.
*/
function MergeArrayValues(vArray, iIndex, iLength, sMergeString) {
  var sFinalValue = vArray[iIndex];
  //var vRemovedItems = vArray.splice(iIndex +1, iLength)
  var vRemovedItems = []
  
  
  var iLastIndex = iIndex + iLength + 1;
  for (var i = iIndex + 1; i < iLastIndex; ++i) {
    if (vArray[i] != "") {
      vRemovedItems.push(vArray[i]);
    }
   
  }
  
  
  sFinalValue += sMergeString + vRemovedItems.join(sMergeString)
  vArray[iIndex] = sFinalValue
  
  
  
}

function _testMergeArrayValues() {
  var vRow = ["Dia feliz", "calca azul", "23", "G", "0", "un", "213,99", "10/20/2002"]
  MergeArrayValues(vRow,1, 2, " - ");
  
  if (vRow[1] != "calca azul - 23 - G") {
    console.log(arguments.callee.name + ": Failed test")
    console.log(vRow)
  }
  else {
    console.log(arguments.callee.name + ": Success")
  }

}
_testMergeArrayValues();


var m_dFields = {
 "Código": "CODIGO",
 "Descrição": "NOME",
 "Unidade": "MEDIDA",
 "Classificação fiscal": "NCM",// todo: talvez eh um codigo especifico pro sistema
 "Preço": "VENDA",
}

// Converts the new system's column to old system column name.
// used to easier access the old system's'
function ConvertColumnName(sName) {
  return m_dFields[sName];
}





// todo: escrever considerando " ; \n. ver como o sistema exporta.
function ConvertCsvColumnValue(sValue) {
  return '"' + sValue + '"';
}

// Converts an array of values into a string that is ready to be a column line of csv text
function ConvertCsvColumn(vValues) {
  var vColumnValues = []
  for (var i in vValues) {
    vColumnValues.push(ConvertCsvColumnValue(vValues[i]))
  }
  
  return vColumnValues.join(";")
}

function _testConvertCsvColumn() {
  
  var sText = ConvertCsvColumn(["Test", "199,00", "P", "213123"])
  
  if (sText != '"Test";"199,00";"P";"213123"') {
    console.log(arguments.callee.name + ": Failed test")
    console.log(vRow)
  }
  else {
    console.log(arguments.callee.name + ": Success")
  }
 
}
_testShitArray();



// Converts a given array to an dic of indices of each array's values
// Used for header columns to faster get the columns index by its name
function ExtractHeaderIndices(vHeaders) {
  var dIndex = {}
  
  var iLength = vHeaders.length;
  for (var iIndex = 0; iIndex < iLength; ++iIndex) {    
    dIndex[vHeaders[iIndex]] = iIndex
  }
   
  
  return dIndex;
  
}

// date received: "02/09/2021 17:32:42"
function IsValidDate(sDate) {
  var sDateYear = sDate
					.split(' ')[0] // "02/09/2021"
					.split('/')[2] // "2021"
  var iYear = parseInt(sDateYear);
  
  return iYear >= 2018;
}

// return array of string, with the csv to be downloaded
function ExportProductData(sProductCsv) {
  var vRows = sProductCsv.split('\n')
  
  // get header indices
  var dHeaderIndex = ExtractHeaderIndices(vRows[0].split(';'))
  
  //console.log(vRows[0]);
  //console.log("Header index");
  //console.log(dHeaderIndex);
  var iAmountIndex = dHeaderIndex["MEDIDA"];
  var iNameIndex = dHeaderIndex["NOME"];
  var iInsertDateIndex = dHeaderIndex["DATAHORINC"]; // index to validate inserted date, to only consider recent values;
  
  // the exported final csv.  todo: split 500
  var vExportedHeaders = [
"ID",
"Código",
"Descrição",
"Unidade",
"Classificação fiscal",
"Origem",
"Preço",
"Valor IPI fixo",
"Observações",
"Situação",
"Estoque",
"Preço de custo",
"Cód no fornecedor",
"Fornecedor",
"Localização",
"Estoque maximo",
"Estoque minimo",
"Peso líquido (Kg)",
"Peso bruto (Kg)",
"GTIN/EAN",
"GTIN/EAN da embalagem",
"Largura do Produto",
"Altura do Produto",
"Profundidade do produto",
"Data Validade",
"Descrição do Produto no Fornecedor",
"Descrição Complementar",
"Unidade por Caixa",
"Produto Variação",
"Tipo Produção",
"Classe de enquadramento do IPI",
"Código da lista de serviços",
"Tipo do item",
"Grupo de Tags/Tags",
"Tributos",
"Código Pai",
"Código Integração",
"Grupo de produtos",
"Marca",
"CEST",
"Volumes",
"Descrição Curta",
"Cross-Docking",
"URL Imagens Externas",
"Link Externo",
"Meses Garantia no Fornecedor",
"Clonar dados do pai",
"Condição do produto",
"Frete Grátis",
"Número FCI",
"Vídeo",
"Departamento",
"Unidade de medida",
"Preço de compra",
"Valor base ICMS ST para retenção",
"Valor ICMS ST para retenção",
"Valor ICMS próprio do substituto",
"Categoria do produto"
  ]
  
  var vCsvFiles = [];
  
  var vCsvLines = [];
  
  vCsvLines.push(ConvertCsvColumn(vExportedHeaders));
  // fazer ao contrario, e ate 500.
  //for (var iRow = 1; iRow < vRows.length; ++iRow) {
  for (var iRow = 1; iRow < vRows.length; ++iRow) {

    var vCol = vRows[iRow].split(';')
    if (vCol.length < 2) {
      continue;
    }
    
    // validate if the row can be exported:
    if (!IsValidDate(vCol[iInsertDateIndex])) {
      continue;
    }
    
    // Shift wrong coluns values, due to products cadastred with ';' instead of '/'
    if (vCol[iAmountIndex] == "") {
      ShiftArray(vCol, iAmountIndex)
    }
    
    // now merge Name and descs into a single column
    MergeArrayValues(vCol, iNameIndex, 3, " - ");
    
    var vColumnValues = []
    // todo: converter column order to final
    var sHeader;     // "Código"
    var sHeaderOld;  // "CODIGO"
    var sOldValue;   // "20161109"
    var iOldValueIndex; // 3
	
	// for each header, try to find it's value in old data.
    for (var iHeaderIndex in vExportedHeaders) {      
      sHeader = vExportedHeaders[iHeaderIndex];
      sHeaderOld = m_dFields[sHeader];
      if (sHeaderOld != null) {
        iOldValueIndex = dHeaderIndex[sHeaderOld];
        
        
        if (iOldValueIndex != null) {
          
          vColumnValues.push(vCol[iOldValueIndex]);
        }
        else {
          ConsoleLogOnce("Field " + sHeaderOld + " not found");
          vColumnValues.push("");
        }
      }
      else {
        vColumnValues.push("");
      }
    }
    
    vCsvLines.push(ConvertCsvColumn(vColumnValues))
    // reached the limit per csv?
	if (vCsvLines.length == iMaxPerCsv) {
		// yes, then push result into csv files
		vCsvFiles.push(vCsvLines.join('\n'));
		
		vCsvLines = [];
		vCsvLines.push(ConvertCsvColumn(vExportedHeaders));
	}
	
	
  }
  
  
	// push last products into result:
	if (vCsvLines.length >= 0) {
		// yes, then push result into csv files
		vCsvFiles.push(vCsvLines.join('\n'));
	}
  return vCsvFiles;
}

m_dAlreadyPrinted = {}
function ConsoleLogOnce(sText) {
  if (m_dAlreadyPrinted[sText] == null) {
    console.log(sText);
    m_dAlreadyPrinted[sText] = true;
  }
}

//console.log(ExportProductData(m_sImportTestData));






</script>

<p><strong>Tip:</strong> Use the Control or the Shift key to select multiple files.</p>

</body>
</html>

